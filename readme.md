# Raytracer

В этой задаче вам предстоит написать игрушечный рейтрейсер, с помощью которого можно
рендерить простейшие сцены.

Основная часть задачи будет описана на семинаре, здесь приведены детали, не вошедшие в запись плюс небольшое резюме рассказанного.

Презентация с семинара лежит в файлах задачи.

Вам необходимо реализовать функцию
```
Image Render(const std::string& filename, const CameraOptions& camera_options, const RenderOptions& render_options); 
```

Эта функция должна быть реализована в файле `raytracer.h`. Обратите внимание, что помимо этого вы можете создавать
произвольное число `.h` файлов для реализации. Все они будут отправляться
на сервер. Однако используйте синтаксис `#include <header.h>` для инклудов, если также хотите иметь
возможность сдавать бонусы.

### Настройка окружения

На ubuntu установите следующие библиотеки:
```
sudo apt-get install libjpeg-dev libpng-dev
```

Для Mac:
```
brew install libpng libjpeg
```

### Тесты

Каждый тест представляет из себя сравнение результата вашего рендера и авторского на одних и тех же входных данных.
Отлаживать свое решение на уже готовой сцене по полному прогону может быть достаточно тяжело. Поэтому мы настоятельно рекомендуем вам также написать
собственные юнит-тесты, которые проверяют отдельные части вашего рейтрейсера (позиционирование камеры, геометрию, операции с векторами и т.д.).

Обратите внимание, что в каждом тесте вы можете добавить в `CheckImage` дополнительный аргумент - путь до .png файла, куда будет
записан результат вашего рендера. Вы можете как угодно менять файл с тестами - он не отправляется на сервер.

Вы также можете использовать фильтры, чтобы запустить только нужный вам тест. Например
```
./test_raytracer "Box with spheres"
```

В силу структуры тестов у некоторых может возникнуть соблазн считать авторский ответ и выдать его как свой. Авторы
таких "решений" получат неуд. за весь курс.

### Освещение

Освещенность в точке $`p`$ некоторого объекта задается формулой
```math
I_p = I_{base}(p) + I_{comp}(p),
```

где
```math
I_{base}(p) = K_a + K_e + \sum_{m \in lights} (K_d I_d(p, m) + K_s I_s(p, m))
```

Сумма берется по всем источникам света, которые видны из точки $`p`$ (все объекты считаются непрозрачными при проверке на видимость). $`I_d`$ и $`I_s`$
это соответственно diffuse и specular составляющие освещения из модели Фонга (https://en.wikipedia.org/wiki/Phong_reflection_model).

$`I_{comp}`$ вычисляется только в том случае, если для заданного объекта нужно считать отраженный и преломленный лучи (это будет задаваться
в свойствах материалов), и в этом случае эта величина считается так:
```math
I_{comp}(p) = (1.0 - d)I_{refract}(p) + K_d I_d(p, I_{reflect}(p)) + K_s I_s(p, I_{reflect}(p))
```

Здесь $`d`$ - степень непрозрачности объекта, $`I_{refract}(p)`$ - освещенность от преломленного в точке $`p`$ луча, а $`I_{reflect}(p)`$ - освещенность
отраженного в $`p`$ луча. Обратите внимание, что отраженный луч не нужно считать, если сейчас трассируются
луч внутри объекта (в нашем случае если трассируется преломленный луч внутри полупрозрачной сферы).

### Постпроцессинг

#### Tone Mapping

Когда рендеринг завершен, и для каждой точки известна тройка `v = (r, g, b)`, нужно произвести ряд действий.
Основная проблема состоит в том, что эти значения могут быть больше 1, а чтобы сохранить изображение нужно иметь значения в диапазоне `[0,1]`.
Процедура приведения этих значений в диапазон `[0,1]` обычно называется [tone mapping](https://en.wikipedia.org/wiki/Tone_mapping), и в нашем задании ее нужно сделать следующим
образом:

* Пусть наибольшее значение среди всех `(r, g, b)` по всем точкам изображения равно `C` (это скаляр, т.е. максимум берется и по самим тройкам).
* Тогда вектор $`V_{in} = (r, g, b)`$ нужно преобразовать в выходной $`V_{out}`$ по правилу (все операции выполняются поэлементно)
```math
V_{out} = \dfrac{V_{in}\left(1 + \dfrac{V_{in}}{C^2}\right)}{1 + V_{in}}
```

#### Гамма коррекция

Теперь когда все значения лежат в диапазоне `[0,1]` осталось сделать последний шаг. Все вычисления при рендеринге выполнялись в линейном RGB,
но при сохранении изображений линейный RGB практически никогда не используется, т.к. в этом случае нужно выделять больше 8 бит на канал (например
иметь значения в диапазоне `[0, 2^16)`), чтобы изображение выглядело нормально. Пусть значение $`V_{out}`$ получено с предыдущего шага.
Тогда в итоговое изображение нужно записать
```math
V_{gamma} = V_{out}^{\frac{1}{2.2}}
```

Обратите внимание, что класс `Image`, через который происходит запись изображений, ожидает целочисленные rgb, т.е. полученное $`V_{gamma}`$ нужно
домножить на 255 и привести в целые числа.

Подробнее можно прочитать на вики (https://en.wikipedia.org/wiki/Gamma_correction) если интересно.

### Формат .obj файлов

Описание формата можно посмотреть на вики: https://en.wikipedia.org/wiki/Wavefront_.obj_file. В нашем случае можно отметить следующее:

* Необходимо поддерживать только строчки с v, vt, vn, f, mtllib и usemtl, остальное нужно игнорировать.
* Нумерация сущностей в f глобальная, т.е. нужно игнорировать различные группирующие модификаторы вроде g или o.
* В f может быть задано произвольное число вершин, но гарантируется, что они образуют выпуклый многоугольник и заданы в порядке
обхода по или против часовой стрелки, т.е. их можно сразу нарезать на треугольники. Необходимо поддерживать все возможные варианты
задания вершин в f (с индексом нормали и/или текстуры). При этом саму поддержку текстурирования в базовой части задания делать не нужно.
* Гарантируется, что файл, определенный в mtllib, находится в той же директории, что и .obj файл.
* Для удобства в нашем задании также нужно уметь обрабатывать строчки вида `S x y z r`. Такая строка задает сферу с центром в `(x, y, z)`
радиуса `r`.
* Помимо этого нужно обрабатывать строки вида `P x y z r g b`. Такая строка задает точечный источник света с координатами `(x, y, z)`, имеющий
интенсивность `(r, g, b)`. Обратите внимание, что `(r, g, b)` необязательно лежат в диапазоне `[0,1].`

Касательно .mtl файлов описание приведено там же на вики, есть следующие нюансы:

* Необходимо поддерживать строки с illum, newmtl, Ka, Kd, Ks, Ke, Ns, Ni, d, Tr. Все остальное нужно игнорировать.
* Модификатор Ke нестандартный, но часто встречается в реальных .mtl файлах. В нашем задании его нужно обрабатывать так же, как и Ka, т.е.
как аддитивную прибавку к суммарному освещению объекта.
* Модификаторы `d` и `Tr` задают прозрачность объекта в виде `d value` или `Tr value`. Может быть задан как один, так и другой, при этом `value`
лежит в диапазоне `[0,1]`, а смысл у модификаторов прямо противоположный - `d` задает насколько непрозрачен объект (`d 1` полностью непрозрачен,
мы считаем это значением по умолчанию если модификатора в материале нет), а `Tr` наоборот.
* illum нужно обрабатывать следующим образом - если значение > 2, то необходимо также посчитать отраженный и преломленный лучи, иначе нет.

### Бонусы

У этой задачи есть 2 бонусных подзадачи:

* поддержка текстур https://gitlab.com/slon/shad-cpp0/-/tree/master/raytracer-b1
* ускорение рендеринга https://gitlab.com/slon/shad-cpp0/-/tree/master/raytracer-b2